Коллекции JAVA: Введение

1. Тип Object

    * lec3_1.java - тип Object
    * lec3_2. java - тип Object, метод Sum для разных типов данных

    Упаковка - любой тип данных можно положитьв переменную типа Object
    Распаковка - преобразование Object-переменной в нужный тип
    Иерархия типов - любой тип "ниже" Object'а

    зачем обжект? взять метод, где в качестве аргументов указать обджекты и внутри метода проверить какого типа переменная 
    тогда не нужно 100500 методов для каждого типа переменной

2. Массивы

    как увеличить размер массива?

    * lec3_3.java - есть массив из двух элементов, необходимо добавить третий;

    взять первый массив, взять второй массив юольше первого, все элементы первого перенести во второй и работать уже со вторым
    что происходит в памяти?

      RAM 
        stack             heap (управляемая куча)
      |  | a |  |  | temp ||  |  |  | d |  | nd |
      |  | a |  |  |  ||  |  |  |  |  | nd |

      a -> d
      temp -> nd
      a -> nd  (подмена сслыки - а ссылается на новое место где хранятя данные)
      потом постепенно будет стерты из памяти данные d, а потом сслылка или адрес памяти - temp
      мы увеличили массив а, но если ээто будет происходить много раз и для большого кол-ва пользователей - это скажетя на производительности;
      с такими операциями нужно быть аккуратными;

      в stack определяются только те типы с которыми мы знаем как работать;
      например, определили переменную типа интеджер, она занимает 4 байта, и не при каких условиях она не может стать больше;
      в таком случае в stack выделяется 4 байта памяти;

      но если мы хотим определить переменную типа стринг, непонятно сколько памяти выделять, если там одна буква, то это 2 байта;
      а если там целая книга -?
      то же самое и с массивами, когда мы создаем переменную, мы не знаем сколько там будет элементов;
      когда пишем new int ... тогда происходит выделения памяти в куче, но саму переменную тоже нужно где-то хранить;
      в таком случае ссылка, которая в нашем случае представляется идентификатором массива - она будет сохранятся в stack;
      а все что непосредственно содержится в массиве будет сохраняться в управляемой куче;

    как выйти из ситуации? 
      если мы не знаем сколько точно будет элементов в массиве(наприме,р скорее всего не более 100, но может и 10), 
      то лучше взять памяти чуть-чуть побольше, чтобы потом не увеличивать размер;
    
     если увеличиваем массив с помощью метода:

        RAM 
        stack             heap (управляемая куча)
      |  | a | array |  | temp ||  |  |  | d |  | nd |
      |  | a |  |  |  ||  |  |  |  |  | nd |

      a -> d
      array -> d (array - переменная котороая выступает в качестве аргумента метода)
      temp -> nd
      array -> nd
      a -> nd
      потом постепенно array и temp удалятся из памяти, а ссылка на данные будет содержаться в исходном массиве а;

    итого: по одному элементу добавлять невыгодно - либо берем с запасом,
      либо как сделали разработчики - при добавлении одного эелемента, массив автоматически расширяется на 10 или 16 элементов (точно не помню);

3. Коллекции

    * lec3_4.java - пример с Row Type и Save Type; ArrayList
    * lec3_5.java - пример с Row Type; ArrayList
    * lec3_6.java - пример с Save Type; ArrayList

    Иерархия коллекций:

    <<interface>> Collection - в основе всего

    от которого являются производными(наследуются) следующие коллекции: <<interface>>Set, <<interface>>List, <<interface>>Queue;

     <<interface>>Set: HashSet(<- LinkedHashSet), <<interface>>SortedSet(<- <<interface>>NavigabledSet(<- TreeSet));
     <<interface>>List: ArrayList, Vector, LinkedList;
     <<interface>>Queue: LinkedList, PriorityQueue;
    
    отдельно идет множество коллекций MAP - но они идут отдельно от данной иерархии;

    Коллекция ArrayList:

        "Удобный массив"
        Разные способы создания:
        ArrayList list = new ArrayList();

        С точки зрения памяти:
        RAM
        stack             heap
        |  | list |  |  |  ||  |  |  |  |  | data |  |

        определяем мето для ссылки list (4 байта в стеке);
        с помощью конструктора new выделяем какое-то количество памяти для data в куче;
        а потом работаем - внутри мехнизмы могут быть построены по разному;
        внутри коллекций могут лежать массивы или списки;

    Иерархия коллекции. List
        Пример одной из простых коллекций - это ArrayList;
        List - пронумерованный набор элементов;
        Пользователь этого интерфейса имеет точный контроль над тем, где в списке вставляется каждый эл-т;
        Пользователь может обращаться к эл-там по их целочисленному индексу(позиции в списке) и искать эл-ты в списке;
        к коллекции List относятся - ArrayList, LinkedList (Vector, Stack - устаревшие);
        если есть какой-либо функционал для одной коллекции(например, метод add) - он будет и для другой, 
        но у них может быть разное поведение, но мы пока не знаем каким-образом данные будут храниться внутри;

        ArrayList<Integer> list1 = new ArrayList<Integer>(); обязательно указываем тип данных;
        ArrayList<Integer> list2 = new ArrayList<>(); второй раз указывать уже не обязательно;
        ArrayList<Integer> list3 = new ArrayList<>(10); 10 - значит изначально в нашей коллекции будет хранилище под 10 элементов;
        ArrayList<Integer> list4 = new ArrayList<>(list3);
        можно использовать как сырой тип или указывать в угловых скобках тот тип с которым будем работать;
        правильнее использвать указывая тип данных(через обобщение) - поможет избежать ошибок - 
        если знаем что там хранятся допустим числа, значит, там точно не будет ничего другого;

        * lec3_7.java - примеры создания ArrayList;

        Преимущество обобщениий(SaveType):
            - поможет избежать ошибок, 
            - код можно переиспользвать,

    Коллекции. Функционал(методы):

     add(args) – добавляет элемент в список ( в т.ч. на нужную позицию)
     get(pos) – возвращает элемент из списка по указанной позиции
     indexOf(item) – первое вхождение или -1
     lastIndexOf(item) – последнее вхождение или -1
     remove(pos) – удаление элемента на указанной позиции и его возвращение
     set(int pos, T item) – gjvtoftn значение item элементу, который находится на позиции pos
     void sort(Comparator) – сортирует набор данных по правилу
     subList(int start, int end) – получение набора данных от позиции start до end
    
    Если наполняем коллекцию специфичными типами, например, ссылочными типами:
     - если в какой-то помент вмсето примитивных типов начнем использвать сложные?
    
    * lec3_8.java - коллекция с простыми(int) и сложными(stringbuilder) типами

    Коллекции. Функционал(методы):

     clear() – очистка списка
     toString() – «конвертация» списка в строку
     Arrays.asList – преобразует массив в список
     containsAll(col) – проверяет включение всех элементов из col
     removeAll(col) – удаляет элементы, имеющиеся в col
     retainAll(col) – оставляет элементы, имеющиеся в col
     toArray() – конвертация списка в массив Object’ов
     toArray(type array) – конвертация списка в массив type
     List.copyOf(col) – возвращает копию списка на основе имеющегося
     List.of(item1, item2,...) – возвращает неизменяемый список (позволяет сформировать массив на основе каких-либо данных)

    * lec3_9.java - про list of и неизменяемость (нельзя remove)

3. Итератор

    * lec3_10.java - итератор, цикл foreach, while;
    * lec3_11.java - iterator (hasNext(), next(), remove());

    счетчик от начала кoллекции и до конца это не всегда удобно;
    for each - тот объект с которым работаем должен быть итерируемым объектом
    для того чтобы сделать на основе нашей коллекции некий итерируемый объект и получить итератор;
    изменять элементы не нужно точнее нельзя;

    зачем нужен итератор - поэлементно разбирать:
     - для более гибкой работы с данными
     - Интерфейс Iterator<E>. Итератор коллекцией. Iterator занимает место Enumeration в Java Collections Framework. 
     - Итераторы отличаются от перечислений:
        -Итераторы позволяют вызывающей стороне удалять элементы из базовой коллекции во время итерации с четко определенной семантикой.
            - hasNext(), next(), remove()
        - ListIterator<E>  - можно ходить из начала в конец и обратно и по элементам, добавление элементов
            - hasPrevious(), E previous(), nextIndex(), previousIndex(), set(E e), add(E e)

    




    




    






















